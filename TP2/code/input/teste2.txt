%%LEX
tokens =["DELIM_ABRIR","SEPARATOR","NUM","PAL","DELIM_FECHAR"]

\[          return ('t_DELIM_ABRIR', t.value)          ## t_DELIM_ABRIR = r'\['
,           return ('t_SEPARATOR', t.value)            ## t_SEPARATOR = r','
[0-9]+      return ('t_NUM', t.value)                  ## t_NUM = r'[0-9]+'
[a-zA-Z]+   return ('t_PAL', t.value)                  ## t_PAL = r'[a-zA-Z]+'
\]          return ('t_DELIM_FECHAR', t.value)         ## t_DELIM_FECHAR = r'\]'



 \t\n       return('t_ignore', t.value)

.           error('Carater ilegal: ', t.value[0], t.lexer.skip(1)) 





%%YACC

comp = 0
soma = 0
counting = False
output = 0
operacao = 1        ## 1-soma, 2- subtração
erro = False        ## Controlar os erros
parse(linha)        ## Chamar o parse linha a linha




Lista : DELIM_ABRIR Lista2                      {  }
Lista2 : LCont DELIM_FECHAR                     {  }
Lista2 : DELIM_FECHAR                           { comp += 1 }
LCont : NUM LCont2                              { comp += 1 }
LCont : PAL LCont2                              { comp += 1; if(p[1] == 'start'): soma += p[2] }
LCont2 : SEPARATOR NUM LCont2                   { comp += 1; p[0] = int(p[2]) + p[3] }
LCont2 : SEPARATOR PAL LCont2                   { comp += 1; if(p[2] == "start"): soma += p[3]; p[0] = 0 }
LCont2 :                                        { p[0] = 0 }


%%

def p_error(p):
    print ("Error:",p)
    parser.erro = True

parser = yacc.yacc()






